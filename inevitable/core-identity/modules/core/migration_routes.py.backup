"""
Tenant Data Migration API Routes

Provides API endpoints for tenant data migration, export, import, backup and restore.
"""
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, BackgroundTasks
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session
from typing import Optional
from pydantic import BaseModel, Field
import os
import tempfile

from .database import get_db
from .deps import get_current_active_user, get_current_tenant_id
from .migration import tenant_migrator
from ..auth.models import User
from ..auth.permissions import Permission, require_permission

router = APIRouter(prefix="/api/migration", tags=["migration"])


class ExportRequest(BaseModel):
    """Request model for tenant data export"""
    format: str = Field(default="json", description="Export format: json, yaml, sql")
    include_sensitive: bool = Field(default=False, description="Include sensitive data")


class ImportRequest(BaseModel):
    """Request model for tenant data import"""
    target_tenant_id: Optional[str] = Field(None, description="Override tenant ID")
    merge_existing: bool = Field(default=False, description="Merge with existing data")
    validate_only: bool = Field(default=False, description="Only validate, don't import")


class MigrationRequest(BaseModel):
    """Request model for tenant migration"""
    source_tenant_id: str = Field(..., description="Source tenant ID")
    target_tenant_id: Optional[str] = Field(None, description="Target tenant ID")
    target_database_url: Optional[str] = Field(None, description="Target database URL")
    include_audit_logs: bool = Field(default=True, description="Include audit logs")


class BackupRequest(BaseModel):
    """Request model for tenant backup"""
    backup_path: Optional[str] = Field(None, description="Backup directory path")


class RestoreRequest(BaseModel):
    """Request model for tenant restore"""
    backup_file: str = Field(..., description="Path to backup file")
    target_tenant_id: Optional[str] = Field(None, description="Override tenant ID")
    force: bool = Field(default=False, description="Force restore even if data exists")


@router.post("/export")
@require_permission(Permission.TENANT_ADMIN)
async def export_tenant_data(
    request: ExportRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
    tenant_id: str = Depends(get_current_tenant_id)
):
    """
    Export tenant data in specified format
    
    Requires TENANT_ADMIN permission
    """
    try:
        # Create temporary file for export
        temp_file = tempfile.NamedTemporaryFile(
            delete=False,
            suffix=f".{request.format}"
        )
        temp_file.close()
        
        # Perform export
        success, message, file_path = tenant_migrator.export_tenant_data(
            db=db,
            tenant_id=tenant_id,
            export_format=request.format,
            include_sensitive=request.include_sensitive,
            output_path=temp_file.name
        )
        
        if not success:
            raise HTTPException(status_code=400, detail=message)
        
        # Schedule cleanup after download
        def cleanup_file():
            if os.path.exists(file_path):
                os.remove(file_path)
        
        background_tasks.add_task(cleanup_file)
        
        # Return file for download
        return FileResponse(
            path=file_path,
            filename=f"tenant_{tenant_id}_export.{request.format}",
            media_type="application/octet-stream"
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Export failed: {str(e)}")


@router.post("/import")
@require_permission(Permission.TENANT_ADMIN)
async def import_tenant_data(
    file: UploadFile = File(...),
    target_tenant_id: Optional[str] = None,
    merge_existing: bool = False,
    validate_only: bool = False,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
    tenant_id: str = Depends(get_current_tenant_id)
):
    """
    Import tenant data from uploaded file
    
    Requires TENANT_ADMIN permission
    """
    try:
        # Save uploaded file temporarily
        temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=file.filename)
        content = await file.read()
        temp_file.write(content)
        temp_file.close()
        
        # Use current tenant if no target specified
        use_tenant_id = target_tenant_id or tenant_id
        
        # Perform import
        success, message, stats = tenant_migrator.import_tenant_data(
            db=db,
            file_path=temp_file.name,
            target_tenant_id=use_tenant_id,
            merge_existing=merge_existing,
            validate_only=validate_only
        )
        
        # Clean up temp file
        os.remove(temp_file.name)
        
        if not success:
            raise HTTPException(status_code=400, detail=message)
        
        return {
            "success": success,
            "message": message,
            "stats": stats
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Import failed: {str(e)}")


@router.post("/backup")
@require_permission(Permission.TENANT_ADMIN)
async def backup_tenant(
    request: BackupRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
    tenant_id: str = Depends(get_current_tenant_id)
):
    """
    Create a backup of tenant data
    
    Requires TENANT_ADMIN permission
    """
    try:
        success, message, backup_path = tenant_migrator.backup_tenant(
            db=db,
            tenant_id=tenant_id,
            backup_path=request.backup_path
        )
        
        if not success:
            raise HTTPException(status_code=400, detail=message)
        
        return {
            "success": success,
            "message": message,
            "backup_path": backup_path
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Backup failed: {str(e)}")


@router.post("/restore")
@require_permission(Permission.TENANT_ADMIN)
async def restore_tenant(
    request: RestoreRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
    tenant_id: str = Depends(get_current_tenant_id)
):
    """
    Restore tenant from backup
    
    Requires TENANT_ADMIN permission
    """
    try:
        # Use current tenant if no target specified
        use_tenant_id = request.target_tenant_id or tenant_id
        
        success, message, stats = tenant_migrator.restore_tenant(
            db=db,
            backup_file=request.backup_file,
            target_tenant_id=use_tenant_id,
            force=request.force
        )
        
        if not success:
            raise HTTPException(status_code=400, detail=message)
        
        return {
            "success": success,
            "message": message,
            "stats": stats
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Restore failed: {str(e)}")


@router.get("/export/formats")
async def get_export_formats():
    """Get supported export formats"""
    return {
        "formats": tenant_migrator.supported_formats,
        "default": "json"
    }


@router.post("/validate")
@require_permission(Permission.TENANT_ADMIN)
async def validate_import_file(
    file: UploadFile = File(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """
    Validate an import file without performing import
    
    Requires TENANT_ADMIN permission
    """
    try:
        # Save uploaded file temporarily
        temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=file.filename)
        content = await file.read()
        temp_file.write(content)
        temp_file.close()
        
        # Validate only
        success, message, validation_results = tenant_migrator.import_tenant_data(
            db=db,
            file_path=temp_file.name,
            validate_only=True
        )
        
        # Clean up temp file
        os.remove(temp_file.name)
        
        return {
            "valid": success,
            "message": message,
            "validation_results": validation_results
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Validation failed: {str(e)}")


@router.post("/migrate")
@require_permission(Permission.SUPER_ADMIN)
async def migrate_tenant_between_databases(
    request: MigrationRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """
    Migrate tenant data between databases
    
    Requires SUPER_ADMIN permission
    """
    try:
        # This would create a connection to target database
        # For now, we'll use the same database
        target_db = db
        
        # Perform migration in background
        def perform_migration():
            success, message, stats = tenant_migrator.migrate_tenant(
                source_db=db,
                target_db=target_db,
                tenant_id=request.source_tenant_id,
                new_tenant_id=request.target_tenant_id,
                include_audit_logs=request.include_audit_logs
            )
            
            # Log result
            if success:
                logger.info(f"Migration completed: {message}")
            else:
                logger.error(f"Migration failed: {message}")
        
        background_tasks.add_task(perform_migration)
        
        return {
            "message": "Migration started in background",
            "source_tenant_id": request.source_tenant_id,
            "target_tenant_id": request.target_tenant_id or request.source_tenant_id
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Migration failed: {str(e)}")


@router.get("/status/{tenant_id}")
@require_permission(Permission.TENANT_ADMIN)
async def get_tenant_data_status(
    tenant_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """
    Get data status for a tenant
    
    Requires TENANT_ADMIN permission
    """
    try:
        tenant_models = tenant_migrator._get_tenant_models()
        status = {
            "tenant_id": tenant_id,
            "models": {}
        }
        
        for model_name, model_class in tenant_models.items():
            count = db.query(model_class).filter(
                model_class.tenant_id == tenant_id
            ).count()
            
            status["models"][model_name] = {
                "count": count,
                "has_data": count > 0
            }
        
        status["total_records"] = sum(m["count"] for m in status["models"].values())
        
        return status
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get status: {str(e)}")